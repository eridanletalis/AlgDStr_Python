"""
Проанализировать скорость и сложность одного любого алгоритма из разработанных в рамках домашнего задания первых
трех уроков.
Выбрана задача:
2.4 Найти сумму n элементов следующего ряда чисел: 1, -0.5, 0.25, -0.125,… Количество элементов(n) вводится с
клавиатуры.
"""
import cProfile
import sys
import timeit

sys.setrecursionlimit(4000)
"""
Вариант 1. Используем рекурсию

Вариант 2. Используем сумму элементов, вызываемую необходимое число раз

Вариант 3. Преобразование в ряд
Числа 1; -0.5; 0.25; -0.125; ...
Опишем ряд
\sigma(0, n) = (-1/2)^(n-1)
Представляют собой ряд, имеющий следующие свойства:
1. Ряд знакопеременный
2. Каждый последующий элемент ряда строго меньше предыдущего, т.е. модуль члена монотонно убывает.
Отсюда, ряд является сходящимся по признаку Лейбница. Так как ряд \sigma(0, n) = abs((-1/2))^(n-1) тоже является
сходящимся, то ряд сходится абсолютно.
Отсюда можно получить, что сумма элементов ряда не изменится от перестановки слагаемых. 
Отделим положительные и отрицательные элементы ряда. Найдём общую формулу для каждой группы и запишем их в виде 
сумм геометрических прогрессий, затем из первой вычтем вторую. Задача решена.
S1 = 4 * (1 - (1 / 4)^n)/ 3
S2 = 2 * (1 - (1 / 4)^n)/ 3
n1 = n / 2
n2 = n - n1

Результаты эксперимента:
Количество вызовов для варианта 1, варианта 2 и варианта 3 при N = 100: 104, 103 и 4 соотвественно.
Количество вызовов для варианта 1 и варианта 2 при N = 3920 и sys.setrecursionlimit(4000) равно 3924. Вариант с 
рекурсией не может быть вызван более, чем это число раз. 
Вариант 3 вызывается 4 раза.
При N = 100000 вычисления в варианте 2 повторяются 100003 раз, в варианте 3 - 4 раза.

Результаты сведены в таблицу:

Вариант     Описание        Количество вызовов              
                            (N = 100; 3920; 100000) 
                            
1           рекурсия        (104; 3924; -)                
2           циклический     (103; 3924; 100003)             
3           формула         (4; 4; 4)               



"""

N = 10  # количество чисел ряда


# Вариант 1. Реализация рекурсии
def elem_rec(n):
    if n == 1:
        return 1
    elem = 1 / ((-2) ** (n - 1))
    return elem + elem_rec(n - 1)


def recurs_test():
    summa = elem_rec(N)


# Вариант 3. Реализация формулы суммы ряда
def series_test():
    if N % 2 == 0:  # Если количество элементов чётно, просто делим надвое.
        n1 = n2 = int(N / 2)
    else:  # иначе, положительных элементов ряда будет больше, чем отрицательных
        n1 = int(round(N / 2 + 0.5))
        n2 = N - n1

    S1 = 4 * (1 - (1 / 4) ** n1) / 3  # суммируем по положительным элементам
    S2 = 2 * (1 - (1 / 4) ** n2) / 3  # суммируем по отрицательным элементам

    sum = S1 - S2


# Вариант 2. Реализация цикла с вызовом
def elem(n):
    s = 1 / ((-2) ** (n - 1))
    return s


def elements_test():
    n = N
    s = 1
    while n > 1:
        s += elem(n)
        n -= 1


"""
print(f'Сумма рекурсией {float(summa)}')
print(f'Сумма циклическим вызовом функции {float(s)}')
print(f'Сумма формулой {sum}')
"""

for N in (10000, 100000, 1000000):
    print(f"N равно {N}")
    # print("Рекурсия")
    # print(timeit.timeit("recurs_test()", 'from __main__ import recurs_test'))
    print("Формула")
    print(timeit.timeit("series_test()", 'from __main__ import series_test'))
    print("Цикл")
    print(timeit.timeit("elements_test()", 'from __main__ import elements_test'))


# cProfile.run('recurs_test()')
# cProfile.run('series_test()')
# cProfile.run('elements_test()')


"""
Вывод функции измерения времени timeit

N равно 1
Рекурсия
0.170529
Цикл
0.125457
Формула
0.9254805000000002

N равно 10
Рекурсия
4.278949
Цикл
4.240984399999999
Формула
0.7778750999999993

N равно 100
Рекурсия
63.005097899999996
Цикл
63.1885911
Формула
0.7826545999999723

N равно 1000
Рекурсия
1304.0749613
Цикл
1197.1751582999998
Формула
0.7889823999998953

N равно 10000
Формула
0.9825887999999999
Цикл
Не досчитал

Из вывода следует, что наилучшим по времени явялется алгоритм, реализующий сумму знакопеременного ряда, 
записанный формулой, т.к. его время вычисления константно, тогда как остальные имеют сложность O(n)
"""